# 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다

- 클라이언트와 서버의 차이점
    - Socket 라이브러리의 사용법이 다르다.
    - 서버의 애플리케이션은 동시에 다수의 클라이언트 PC와 대화한다
    - **접속하는 측이 클라이언트**
    - **접속을 기다리는 측이 서버**

**멀티태스크**

- 복수의 태스크(프로그램)를 동시에 함께 실행하는 기능
- 하나의 프로세서는 하나의 태스크만 실행할 수 있지만 단기간에 태스크를 전환하면서 실행 ⇒ **동시에 실행하는것 처럼 보임**
- OS의 종류에 따라 멀티프로세스 라고도 불린다.

**멀티스레드**

- 멀티태스크와 같이 복수의 스레드를 동시에 함께 실행하는 기능
- 태스크 ⇒ OS 내부의 하나하나 별도의 프로그램
- 스레드 ⇒ 한 프로그램 속을 몇개의 부분으로 나눈 것으로 취급됨

**접속 동작을 할 때 원래 있던 접속 대기 상태의 소켓은**

- 접속 대기 상태인 채로 계속 존재한다
- 접속 대기의 소켓을 복사하여 새 소켓을 만들고, 새 소켓을 클라이언트 소켓과 연결
- 잇달아 복사하여 새 소켓을 만드는 부분이 요점

---

**웹 서버**

서버 애플리케이션의 동작은 웹 서버 뿐만 아니라 여러 가지 서버 애플리케이션에 공통이지만 서버 애플리케이션의 종류에 따라 달라지는 것은 클라이언트와 대화하는 read를 호출한 뒤 “리퀘스트 메시지의 의뢰 내용을 처리”하는 부분이 달라진다**.**

- read에서 받은 내용 ⇒ HTTP 리퀘스트 메시지
- write를 통해 클라이언트에 반송하는 형태로 작동
    - 이때 어느 소켓을 사용하여 통신하고 있는지를 나타내는 디스크립터를 통지하여 상대 지정
- URL은 데이터의 출처를 나타낸다

메소드가 **GET**이면 **URI 뒤**에 내장된 데이터를 추출하여 건네준다. **POST**면 **본문**에 내장된 데이터를 추출하여 건네준다.

---

**응답 데이터**

- 클라이언트는 웹 서버의 응답 메시지의 맨 앞부분에 있는 Content-Type이라는 헤더 파일 값으로 데이터 종류를 판단한다.

<aside>
💡 `Content-Type : text/html`

- ‘/’ 의 왼쪽 부분은 ‘**주 타입(text)**’ ⇒ **데이터 종류의** **대분류**를 나타낸다.
-  ‘/’ 의 오른쪽 부분은 ‘**서브 타입(html)**’ ⇒ **실제 데이터의 종류**를 나타낸다

**주 타입과 서브 타입의 의미는 모두 결정되어 있다.(전 세계에서 관리)**

</aside>

- 데이터 종류가 텍스트인 경우에는 charset으로 문자 코드의 정보를 부가한다.

데이터의 종류가 판명되면 데이터의 종류에 따라 화면 표시의 프로그램을 호출 —> 데이터를 표시

- 데이터의 종류에 따라 호출하는 프로그램이 결정되며, 브라우저의 설정에 따라 프로그램을 호출하여 데이터를 건네면 화면에 호출한 프로그램이 표시된다. 이후 사용자가 다음 행동을 하기를 기다린다.